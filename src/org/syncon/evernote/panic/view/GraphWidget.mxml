<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
						  xmlns:s="library://ns.adobe.com/flex/spark" 
						  xmlns:mx="library://ns.adobe.com/flex/mx"  
						
						   implements="org.syncon.evernote.panic.view.IUIWidget"
						   creationComplete="onInit()" resize="group1_resizeHandler(event)"
						   fontSize="24" clipAndEnableScrolling="true"
						   color="0xFFFFFF" xmlns:view="org.syncon.evernote.panic.view.*"
						 >
	<!--addedEffect="{this.faFade}" removedEffect="{this.faFadeOut}"-->
	<fx:Metadata>
		[Event(name="tagsChanged", type="org.syncon.evernote.basic.model.CustomEvent")]
	</fx:Metadata>		
	
	<fx:Declarations>
		<s:Fade id="faFade" duration="500" alphaFrom="0" alphaTo="1" />
		<s:Fade id="faFadeOut" duration="500" alphaFrom="1" alphaTo="0" />
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import mx.events.ResizeEvent;
			
			import org.syncon.evernote.basic.model.CustomEvent;
			import org.syncon.evernote.panic.controller.WidgetEvent;
			import org.syncon.evernote.panic.vo.WidgetVO;
			static public var TAGS_CHANGED : String = 'tagsChanged'				
				
			/**
			 * Flag indiates whether tags should be removed instantly 
			 * */
			public var creationComplete : Boolean = false; 
			private var _widgetData : WidgetVO = new WidgetVO
				
			//public var labelBottom : String = ''; 
			//public var labelTop : String = ''; 
			//public var maximum : Number = NaN; 	
			
			
			public function set  widgetData ( w : WidgetVO )  : void { this._widgetData = w }
			public function get   widgetData (  )  : WidgetVO { return this._widgetData; }
			import mx.collections.ArrayCollection;
			
/* 			public var expenses:ArrayCollection = new ArrayCollection([
				{Month:"Jan", Profit:2000, Expenses:1500},
				{Month:"Feb", Profit:1000, Expenses:200},
				{Month:"Mar", Profit:1500, Expenses:500}
			]);
			 */
			[Bindable]
			public var expenses:ArrayCollection = new ArrayCollection([
				{Month:"Jan", Expenses:1500},
			]);
			
			protected function onInit():void
			{
				 this.creationComplete = true
			//	this.importConfig( this._widgetData );
				 group1_resizeHandler(null)
				 this.chart.alpha = 0; 
			}				
				
			
			override public function set  width ( w : Number )  : void
			{
				super.width = w; 
				//this.height = w*(115/99) 
				this.height = 300
				this.chart.height = this.height - 100
				this.chart.width = w*2
			}
			
			protected function group1_resizeHandler(event:ResizeEvent):void
			{
				if ( this.percentWidth != 0 &&  isNaN( this.percentWidth ) == false ) 
				{
					
					var w : Number = this.parentDocument.width*this.percentWidth/100//*(115/99)
					//if ( this.data.vo.height == NaN ) 
					
					///this.width = w; 
					this.height = 300
					this.chart.height = this.height - 100
					 this.chart.width = w*1.3				  
					this.hrLine.width = w*1.5
				}
			}			
			
			public function set textTop( s : String )  : void
			{
				this.lblTop.text = s.toUpperCase()
			}			
			
			public function set textBottom( s : String )  : void
			{
				this.lblBottom.text = s.toUpperCase()
			}
			
			public function set fillC( s : uint )  : void
			{
				this.fade.play([this.chart] ) 
				//s = 0xd2d2d2
				this.fillColor_.color = s; 
				//columnSeries.setStyle('fill', this.fillColor_ ) 
				columnSeries.setStyle('fills', [this.fillColor_] ) 
			}
			
			public function set value ( s : Object )  : void
			{
				if ( s.toString().indexOf('[') == -1 ) 
					s = Number( s ) 
				if ( s is Number ) 
					this.expenses.getItemAt(0).Expenses = s
						
				this.chart.dataProvider = this.expenses; 
			}
			
			public function set maximum ( s : Object )  : void
			{
				if ( s.toString().indexOf('[') == -1 ) 
					s = Number( s ) 
				if ( s is Number ) 
					this.a2.maximum = s as Number; 
			}
			
			/**
			 * Update settings from .... data on config 
			 * two settings 
			 * 
			 * config data 
			 * actual values set 
			 * the temporary values 
			 * 
			 * setter function 
			 * getter function? 
			 * 
			 * to udpate ... pass in temporarly widgetVO
			 * */
			public function refresh(temp  : WidgetVO= null) : void
			{
				var useSettings : WidgetVO = this.widgetData; 
				if ( temp != null ) 
					useSettings = temp; 
				this.dispatchEvent( new WidgetEvent( WidgetEvent.AUTOMATE_WIDGET,
					null, useSettings ) ) 

			}
			
						/**
						 * how tomake sure changes are propgated to vo? 
						 * when ou change them ... call a update vo function 
						 * make in interface, desigend to take props from component and 
						 * copy back to vo the intervew of import config ... 
						 * oh we alreay hae that it's called export great. 
						 * */
 			public function importConfig(j :  WidgetVO )  : void
			{
				if ( j.data == null ) 
					return;
				this.widgetData = j
				this.widgetData.ui = this; 
				this.dispatchEvent( new WidgetEvent(WidgetEvent.IMPORT_CONFIG,  j ) )
					
				this.refresh()
			}
						
			public function importData_( o:   Object )  : void
			{
			}		
			static public function importData( name : String, desc:String, labelTop : String, 
			labelBottom : String, value :  Object, max : Object= null, fillColor : uint = NaN, 
			bgSource : String = '', 
			 refreshTime :  Number=15000)  :  GraphWidget
			{
				var o : Object = {}
				var vo : WidgetVO = new WidgetVO(WidgetVO.GRAPH, o); 	
				var g : GraphWidget = new GraphWidget()
				g.widgetData = vo
				vo.ui = g;
				
				vo.name = name; 
				vo.description = desc
				//vo.source = source; 
				vo.refreshTime = refreshTime; 
				
				o.fillColor = fillColor
				o.labelTop = labelTop
				o.labelBottom = labelBottom
				o.max = max; 
				
				vo.background = bgSource; 
				//a string .. that is scrted to anumber later
				vo.source = value.toString(); 
				return g ; 
			}			
			public function exportConfig( ) : WidgetVO    
			{
				//if not created, don't try to load from ui 
				if ( this.creationComplete == false ) 
					return this._widgetData.clone(); 
				//u can't pull the values like this ... what if they're sourced?
				/*
				_widgetData.data.fillColor = this.fillColor_.color; 
				_widgetData.data.labelTop = labelTop
				_widgetData.data.labelBottom = labelBottom
				_widgetData.data.max = this.maximum; 
				*/				
				return this._widgetData.clone(); 
			}			
			
			
			public function showEdit() : void
			{
				this.editBorder.show()
			}
			
			public function hideEdit()  : void
			{
				this.editBorder.hide()
			}						
		]]>
	</fx:Script>

	<fx:Style>
		.myAxisStyle {
			placement:bottom;
			minorTickPlacement:none;
			tickLength:12;
			tickPlacement:none;
		}
		.myStyle {
			direction:"none";
			horizontalShowOrigin:true;
			horizontalTickAligned:false;
			horizontalChangeCount:0; 
			verticalShowOrigin:false;
			verticalTickAligned:false; 
			verticalChangeCount:0;
			horizontalFill:#990033;
			horizontalAlternateFill:#00CCFF;      
		}  		
	</fx:Style>
	
	<fx:Declarations>
		<!--<s:SolidColor id="fillColor_" color="0xFFDDFF" />-->
		<s:SolidColor id="fillColor_" color="#990033" />
		<s:Fade id="fade" duration="1500"  alphaTo="1" />
		<!-- Define chart effect. -->  
		<mx:SeriesInterpolate id="rearrangeData" 
							  duration="1000" 
							  minimumElementDuration="200" 
							  elementOffset="0"
							  />
	</fx:Declarations>
	

	<s:RichText width="100%" height="100%" id="txtBg" 
				fontLookup="embeddedCFF" fontSize="13" renderingMode="cff"
				paddingBottom="0" paddingLeft="0"  fontFamily="ACaslonProRegularEmbedded"
				paddingTop="0" paddingRight="0" 
				/>	
	
	<s:VGroup  horizontalCenter="0"
			   horizontalAlign="center" clipAndEnableScrolling="false"  width="100%">
		
	
	 
	<s:Label text="..." fontSize="36" id="lblTop" />
		
		<s:VGroup  id="holderForGraphAndhrLine" gap="-3"    horizontalAlign="center" >
			
		
	<mx:BarChart height="80"    id="chart"
				  dataProvider="{expenses}"  >
		<mx:backgroundElements>
		</mx:backgroundElements>
		
		<mx:horizontalAxisRenderers>
			<mx:AxisRenderer  
				axis="{a1}" styleName="myAxisStyle" showLabels="false"
				showLine="false"/>
		</mx:horizontalAxisRenderers>
		<mx:verticalAxisRenderers>
			<mx:AxisRenderer  
				axis="{a1}" styleName="myAxisStyle" showLabels="false"
				showLine="false"
				/>
		</mx:verticalAxisRenderers>		
		
		<mx:horizontalAxis>
			<mx:CategoryAxis  id="a1" 
				dataProvider="{expenses}" 
				categoryField="Month"
				/>
		</mx:horizontalAxis>
		<mx:verticalAxis>
			<mx:LinearAxis  id="a2" 
							 
							   baseAtZero="true"
							  />
		</mx:verticalAxis>		
		<mx:series>
			<mx:ColumnSeries 
				xField="Month"   showDataEffect="rearrangeData"
				yField="Expenses"   id="columnSeries"
				displayName="Expenses" fills="{[this.fillColor_]}"
				/>
		</mx:series>

	</mx:BarChart>
		<s:Line width="100%"  id="hrLine">
			<s:stroke>
				<s:SolidColorStroke color="0x2B2A28" />
			</s:stroke>
		</s:Line>
			
		</s:VGroup>		
<!--	<mx:LineChart height="80%"  width="100%" 
				  dataProvider="{expenses}"  >
			<mx:backgroundElements>
					<mx:GridLines styleName="myStyle">
						<mx:horizontalStroke>
							<mx:SolidColorStroke weight="3"/>
						</mx:horizontalStroke>
						<mx:verticalStroke>
							<mx:SolidColorStroke weight="3"/>
						</mx:verticalStroke>
					</mx:GridLines>
			</mx:backgroundElements>
			<mx:horizontalAxis>
				<mx:CategoryAxis 
					id="a1"   
					dataProvider="{expenses}" 
					categoryField="Month"
					/>
			</mx:horizontalAxis>
			<mx:horizontalAxisRenderers>
				<mx:AxisRenderer 
					axis="{a1}" styleName="myAxisStyle"
					showLine="false"/>
			</mx:horizontalAxisRenderers>
			<mx:verticalAxisRenderers>
				<mx:AxisRenderer 
					axis="{a1}" styleName="myAxisStyle"
					showLine="false"
					/>
			</mx:verticalAxisRenderers>
			<mx:series>
				<mx:LineSeries 
					yField="Profit" 
					displayName="Profit"
					/>
				 
			</mx:series>
		</mx:LineChart>-->

	<s:Label  id="lblBottom" text="Transcode"  maxDisplayedLines="1"   />
	</s:VGroup>
	
	
	<view:EditBorder id="editBorder" edit="{this}" />
</s:Group>
